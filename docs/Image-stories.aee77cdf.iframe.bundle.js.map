{"version":3,"file":"Image-stories.aee77cdf.iframe.bundle.js","mappings":";;AAsBA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;;;;;;;;;;;AAWA;;;;;;;;AAQA;;;AAKA;AACA;AAGA;;;;;;;;;;AC7CA;AACA;;;;AAmGA","sources":["webpack://@arthur/docs/../../packages/arthur-ui/src/Icon/Icon.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Image/Image.tsx"],"sourcesContent":["import React, { forwardRef, useCallback } from 'react';\r\nimport styled, { css } from 'styled-components';\r\nimport classNames from 'classnames';\r\nimport { type IconValue, type IconSizes, IconSizesEnum } from './types';\r\nimport { ICON_VALUES } from './constants';\r\n\r\nexport interface IconProps {\r\n    className?: string;\r\n    /**\r\n     * @default false\r\n     */\r\n    disabled?: boolean;\r\n    /**\r\n     * @default medium\r\n     */\r\n    size?: IconSizes;\r\n    onClick?: (event: React.MouseEvent<HTMLSpanElement>) => unknown;\r\n    value: IconValue;\r\n}\r\n\r\nconst iconSizeStyles = {\r\n    'small-1x': css`\r\n        font-size: ${(props) => props.theme.token.size.font['small-1x']};\r\n    `,\r\n    small: css`\r\n        font-size: ${(props) => props.theme.token.size.font.small};\r\n    `,\r\n    medium: css`\r\n        font-size: ${(props) => props.theme.token.size.font.medium};\r\n    `,\r\n    large: css`\r\n        font-size: ${(props) => props.theme.token.size.font.large};\r\n    `,\r\n};\r\n\r\nconst StyledRoot = styled.span<{ disabled?: boolean }>`\r\n    background-color: transparent;\r\n    border: 0px none;\r\n    outline: 0px none;\r\n    padding: 0px;\r\n\r\n    &:not(.arthur-icon--disabled) {\r\n        &.arthur-icon--clickable {\r\n            &:hover,\r\n            &:focus,\r\n            &:active {\r\n                color: ${(props) => props.theme.token.color.palette.gold.base};\r\n                cursor: pointer;\r\n                outline: 0px none;\r\n            }\r\n        }\r\n    }\r\n\r\n    &.arthur-icon--disabled {\r\n        color: ${(props) => props.theme.token.color.action.text.primary.disabled};\r\n        cursor: default;\r\n    }\r\n`;\r\n\r\nconst StyledIcon = styled.i<{ size: IconSizes }>`\r\n    ${(props) => iconSizeStyles[props.size]}\r\n`;\r\n\r\nconst Icon = forwardRef<HTMLSpanElement | HTMLButtonElement, IconProps>((props, forwardedRef) => {\r\n    const { className, disabled, size = 'medium', value, onClick, ...rest } = props;\r\n\r\n    const iconClass = ICON_VALUES[value];\r\n\r\n    if (!IconSizesEnum[size]) {\r\n        throw new Error(`icon: invalid size \"${size}\"`);\r\n    }\r\n\r\n    const isClickable = disabled === true || typeof onClick === 'function';\r\n\r\n    const handleClick = useCallback(\r\n        (event: React.MouseEvent<HTMLSpanElement>) => {\r\n            if (disabled) return;\r\n\r\n            onClick?.(event);\r\n        },\r\n        [disabled, onClick],\r\n    );\r\n\r\n    const classes = {\r\n        root: classNames(className, 'arthur-icon', `arthur-icon--size-${size}`, {\r\n            'arthur-icon--clickable': isClickable,\r\n            'arthur-icon--disabled': disabled === true,\r\n        }),\r\n        regular: classNames('arthur-icon-regular', 'fa-regular', {\r\n            'fa-foobar': Boolean(iconClass) && Boolean(value),\r\n            [iconClass]: Boolean(iconClass),\r\n            [value as string]: Boolean(iconClass) && Boolean(value),\r\n        }),\r\n    };\r\n\r\n    // The wrapping span is needed because an error is thrown if one attempts\r\n    // to remove this from the dom once it is rendered. This is because the \"rendered\"\r\n    // node is the <i /> element, but a sibling <svg /> element is created as well.\r\n    // Without the wrapper and in the case that the element is added and removed again,\r\n    // React throws.\r\n    return (\r\n        <StyledRoot\r\n            as={isClickable ? 'button' : 'span'}\r\n            className={classes.root}\r\n            disabled={disabled}\r\n            onClick={handleClick}\r\n            ref={forwardedRef}\r\n        >\r\n            <StyledIcon className={classes.regular} size={size} {...rest} />\r\n        </StyledRoot>\r\n    );\r\n});\r\n\r\nexport default Icon;\r\n\r\nIcon.displayName = 'Icon';\r\n","// istanbul ignore file: it is difficult to load images to then test the auto-layout portion of the code here; however, the story for this component covers all scenarios\r\nimport type { CSSProperties, ReactEventHandler, SyntheticEvent } from 'react';\r\nimport React, { forwardRef, useCallback, useEffect, useMemo, useState } from 'react';\r\nimport styled from 'styled-components';\r\nimport classNames from 'classnames';\r\nimport Icon from '../Icon';\r\nimport { useEnsureRef } from '../hook';\r\n\r\nconst StyledRoot = styled.span<ImageProps & TransientProps>`\r\n  align-items: center;\r\n  box-sizing: border-box;\r\n  display: flex;\r\n  justify-content: center;\r\n  overflow: hidden;\r\n\r\n  &.arthur-image--failure {\r\n    & .arthur-image-icon {\r\n      &::after {\r\n        ${(props) => (props.$errorText || props.$alt) && `margin-left: ${props.theme.token.size.spacing['small-2x']};`}\r\n        content: \"${(props) => props.$errorText || props.$alt || ''}\";\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nexport interface ImageProps {\r\n  className?: string;\r\n  /**\r\n   * Describes the [standard \"alt\" attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#alt) on img elements.\r\n   *\r\n   * @default undefined\r\n   */\r\n  alt?: string;\r\n\r\n  /**\r\n   * Controls whether or not the inner image should center and proportion itself to its parent element.\r\n   *\r\n   * @default true\r\n   */\r\n  autoLayout?: boolean;\r\n\r\n  /**\r\n   * Describes the text to be displayed after the ImageProps#onError event fires.\r\n   *\r\n   * @default undefined\r\n   */\r\n  errorText?: string;\r\n\r\n  /**\r\n   * Describes the height style of the root element. When provided as a number, it is treated as pixels.\r\n   *\r\n   * @default undefined\r\n   */\r\n  height?: string | number;\r\n\r\n  /**\r\n   * Describes the max-height style of the root element. When provided as a number, it is treated as pixels.\r\n   *\r\n   * @default undefined\r\n   */\r\n  maxHeight?: string | number;\r\n\r\n  /**\r\n   * Describes the max-width style of the root element. When provided as a number, it is treated as pixels.\r\n   *\r\n   * @default undefined\r\n   */\r\n  maxWidth?: string | number;\r\n\r\n  /**\r\n   * Describes the min-height style of the root element. When provided as a number, it is treated as pixels.\r\n   *\r\n   * @default undefined\r\n   */\r\n  minHeight?: string | number;\r\n\r\n  /**\r\n   * Describes the min-width style of the root element. When provided as a number, it is treated as pixels.\r\n   *\r\n   * @default undefined\r\n   */\r\n  minWidth?: string | number;\r\n\r\n  /**\r\n   * Describes the [standard \"src\" attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#src) on img elements.\r\n   *\r\n   * @default \"\"\r\n   */\r\n  src?: string;\r\n\r\n  /**\r\n   * Describes the width style of the root element. When provided as a number, it is treated as pixels.\r\n   *\r\n   * @default undefined\r\n   */\r\n  width?: string | number;\r\n\r\n  /**\r\n   * Handles the [standard \"onerror\" event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/error_event) on HTML elements.\r\n   *\r\n   * @default undefined\r\n   */\r\n  onError?: (event: SyntheticEvent<HTMLImageElement>) => void;\r\n\r\n  /**\r\n   * Handles the [standard \"onload\" event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/load_event) on HTML elements.\r\n   *\r\n   * @default undefined\r\n   */\r\n  onLoad?: (event: SyntheticEvent<HTMLImageElement>) => void;\r\n  style?: CSSProperties;\r\n}\r\n\r\ninterface TransientProps {\r\n  $alt?: string;\r\n  $errorText?: string;\r\n}\r\n\r\nconst Image = forwardRef<HTMLSpanElement, ImageProps>((props, forwardedRef) => {\r\n  const {\r\n    alt,\r\n    autoLayout,\r\n    className,\r\n    errorText,\r\n    height,\r\n    maxHeight,\r\n    maxWidth,\r\n    minHeight,\r\n    minWidth,\r\n    src,\r\n    style,\r\n    width,\r\n    onError,\r\n    onLoad,\r\n    ...rest\r\n  } = props;\r\n\r\n  const rootRef = useEnsureRef(forwardedRef);\r\n  const [loaded, setLoaded] = useState<boolean | null>(null);\r\n\r\n  // useEffect(() => {\r\n  //   setLoaded(null);\r\n  // }, [src]);\r\n\r\n  useEffect(() => {\r\n    let timeoutId: NodeJS.Timeout;\r\n    function onResize() {\r\n      // resets timeout if applicable\r\n      clearTimeout(timeoutId);\r\n\r\n      // throttle resize calculations if resize events are happening in quick succession\r\n      timeoutId = setTimeout(() => {\r\n        rootRef.current && doLayout(rootRef.current);\r\n      }, 150);\r\n    }\r\n\r\n    if (autoLayout === true && rootRef.current) {\r\n      window.addEventListener('resize', onResize);\r\n    }\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      window.removeEventListener('resize', onResize);\r\n    };\r\n  }, [autoLayout, rootRef]);\r\n\r\n  const classes = classNames(className, 'arthur-image', {\r\n    'arthur-image--success': loaded,\r\n    'arthur-image--failure': !loaded,\r\n  });\r\n\r\n  const styles = useMemo(() => {\r\n    return {\r\n      height: formatSize(height),\r\n      maxHeight: formatSize(maxHeight),\r\n      maxWidth: formatSize(maxWidth),\r\n      minHeight: formatSize(minHeight),\r\n      minWidth: formatSize(minWidth),\r\n      width: formatSize(width),\r\n      ...style,\r\n    };\r\n  }, [height, maxHeight, maxWidth, minHeight, minWidth, style, width]);\r\n\r\n  const handleOnError = useCallback<ReactEventHandler<HTMLImageElement>>(\r\n    (event: SyntheticEvent<HTMLImageElement>) => {\r\n      setLoaded(false);\r\n      onError?.(event);\r\n    },\r\n    [onError],\r\n  );\r\n\r\n  const handleOnLoad = useCallback<ReactEventHandler<HTMLImageElement>>(\r\n    (event: SyntheticEvent<HTMLImageElement>) => {\r\n      if (autoLayout === true && rootRef.current) {\r\n        doLayout(rootRef.current);\r\n      }\r\n\r\n      setLoaded(true);\r\n      onLoad?.(event);\r\n    },\r\n    [autoLayout, onLoad, rootRef],\r\n  );\r\n  console.log('%c loaded', 'color: magenta;', loaded);\r\n\r\n  return (\r\n    <StyledRoot $alt={alt} $errorText={errorText} className={classes} ref={rootRef} style={styles}>\r\n      {!loaded && <Icon className='arthur-image-icon' size='large' value='fa-image-slash' />}\r\n      <img\r\n        alt={alt}\r\n        className='arthur-image-img'\r\n        onError={handleOnError}\r\n        onLoad={handleOnLoad}\r\n        src={src || ''} // REMARK: THIS WILL FORCE THE ERROR EVENT TO FIRE IN THE EVENT THAT NOTHING IS PROVIDED TO ImageProps#src\r\n        {...rest}\r\n      />\r\n    </StyledRoot>\r\n  );\r\n});\r\n\r\nexport default Image;\r\nImage.displayName = 'Image';\r\n\r\nfunction formatSize(value?: string | number): string | undefined {\r\n  if (typeof value === 'number') {\r\n    return `${value}px`;\r\n  }\r\n\r\n  if (Boolean(value) && typeof value === 'string') {\r\n    return value;\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\nfunction doLayout(root: HTMLSpanElement) {\r\n  const { offsetHeight: rootH, offsetWidth: rootW } = root;\r\n\r\n  const img = root.querySelector<HTMLImageElement>('.arthur-image-img');\r\n  if (!img) {\r\n    return;\r\n  }\r\n\r\n  const { naturalHeight: imgH, naturalWidth: imgW } = img;\r\n\r\n  if (imgH <= 0 || imgW <= 0) {\r\n    return;\r\n  }\r\n\r\n  let newW: number | undefined;\r\n  let newH: number | undefined;\r\n\r\n  // if landscape img\r\n  if (imgW > imgH) {\r\n    if (rootW > rootH) {\r\n      if (imgW >= rootW) {\r\n        newW = rootW;\r\n      } else {\r\n        newH = rootH;\r\n      }\r\n    } else {\r\n      newH = rootH;\r\n    }\r\n    // if portrait img\r\n  } else if (imgW < imgH) {\r\n    if (rootW < rootH) {\r\n      if (imgH >= rootH) {\r\n        newH = rootH;\r\n      } else {\r\n        newW = rootW;\r\n      }\r\n    } else {\r\n      newW = rootW;\r\n    }\r\n    // if square img\r\n  } else if (rootW < rootH) {\r\n    newH = rootH;\r\n  } else {\r\n    newW = rootW;\r\n  }\r\n\r\n  if (newW) {\r\n    img.style.width = `${newW}px`;\r\n  }\r\n\r\n  if (newH) {\r\n    img.style.height = `${newH}px`;\r\n  }\r\n\r\n  // the above centering/scaling works most of the time,\r\n  // but it does fail to completely fill the root element;\r\n  // the below conditionally applies a minor adjustment if necessary\r\n  if (newH && root.offsetWidth > img.offsetWidth) {\r\n    img.style.width = `${root.offsetWidth}px`;\r\n  } else if (newW && root.offsetHeight > img.offsetHeight) {\r\n    img.style.height = `${root.offsetHeight}px`;\r\n  }\r\n}\r\n"],"names":[],"sourceRoot":""}