{"version":3,"file":"Card-stories.1f13ad7f.iframe.bundle.js","mappings":";;AAQA;AAEA;;;;AAOA;AACA;;;;;;;AAOA;;;;;AAKA;AACA;;;;AAIA;;;;AAIA;;;AAGA;;;;AAIA;;;;;AAKA;;;AAGA;;;;;AAKA;;;;AAIA;;;AAGA;AAYA;;;ACxEA;AAGA;ACLA;;AAEA;AAGA;;ACKA;AACA;;AAEA;AACA;;;;;;;AAOA;;;;;AAKA;;;AAwEA;AChEA;;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;;AAEA;AAIA;AAEA;AACA;;;AAGA;;;;AAIA;AACA;AACA;;AAGA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;;AAGA;;AAEA;AACA;;;AAGA;;;;;AAKA;AACA;AACA;;;;;AAKA;;AAGA;AACA;AACA;;;AAGA;;;;AAIA;AACA;AACA;;AAKA;;AAOA;AACA;;;;;AAKA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;;;;;;;;AAYA;ACrIA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;;;;;;;;;;;AAWA;;;;;;;;AAQA;;;AAKA;AACA;AAGA;;;;;;;;;;AC7CA;AACA;;;;AAmGA","sources":["webpack://@arthur/docs/../../packages/arthur-ui/src/Card/CardHeading.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Card/CardFooter.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Card/CardContent.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Card/Card.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Button/Button.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Icon/Icon.tsx","webpack://@arthur/docs/../../packages/arthur-ui/src/Image/Image.tsx"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-non-null-assertion -- for icon value */\nimport styled, { css } from 'styled-components';\nimport type { IconValue } from '../Icon';\nimport Icon from '../Icon';\nimport type { CardVariant } from './types';\n\nconst variantStyles = {\n  default: css`\n    background-color: ${(props) => props.theme.token.color.white};\n  `,\n  blog: css`\n    & .arthur-card-headerbreak {\n      display: none;\n    }\n  `,\n};\n\nconst StyledRoot = styled.section<{ variant: CardVariant }>`\n  color: ${(props) => props.theme.token.color.black};\n  margin: 0px 0px 12px 0px;\n  padding: 0px;\n  display: flex;\n  flex-direction: column;\n\n  & .arthur-card-icon {\n    color: ${(props) => props.theme.token.color.palette.gold.base};\n    display: block;\n  }\n\n  & .arthur-card-subheader {\n    color: ${(props) => props.theme.token.color.black};\n    font-weight: ${(props) => props.theme.token.weight.font.medium};\n    margin: 0px;\n    padding: 0px;\n    text-transform: uppercase;\n    font-size: ${(props) => props.theme.token.size.font.small};\n  }\n\n  & .arthur-card-header {\n    color: ${(props) => props.theme.token.color.black};\n    margin: 0px;\n    padding: 8px 0px;\n    font-size: ${(props) => props.theme.token.size.font['large-2x']};\n  }\n\n  & .arthur-card-headerbreak {\n    background: ${(props) => props.theme.token.color.palette.gold.base};\n    height: 3px;\n  }\n\n  & .arthur-card-icon {\n    margin-bottom: ${(props) => props.theme.token.size.spacing['large-1x']};\n\n    & svg {\n      font-size: ${(props) => props.theme.token.size.font['large-1x']};\n    }\n  }\n\n  & .arthur-card-metadata {\n    font-size: ${(props) => props.theme.token.size.font['small-1x']};\n    text-transform: uppercase;\n    display: flex;\n    justify-content: space-between;\n    margin-bottom: ${(props) => props.theme.token.size.spacing.small};\n  }\n\n  ${(props) => variantStyles[props.variant]}\n`;\n\nexport interface CardHeadingProps {\n  subheader?: string;\n  header: string;\n  icon?: IconValue;\n  variant: CardVariant;\n  primaryMetadata?: string;\n  secondaryMetadata?: string;\n}\n\nexport function CardHeading(props: CardHeadingProps) {\n  const { subheader, header, icon, variant, primaryMetadata, secondaryMetadata } = props;\n\n  const hasMetadata = Boolean(primaryMetadata) || Boolean(secondaryMetadata);\n  return (\n    <StyledRoot className='arthur-card-heading' variant={variant}>\n      {Boolean(hasMetadata) && (\n        <div className='arthur-card-metadata'>\n          {Boolean(primaryMetadata) && <div className='arthur-card-metadata-primary'>{primaryMetadata}</div>}\n          {Boolean(secondaryMetadata) && <div className='arthur-card-metadata-secondary'>{secondaryMetadata}</div>}\n        </div>\n      )}\n      {Boolean(icon) && <Icon className='arthur-card-icon' size='large' value={icon!} />}\n      {Boolean(subheader) && <h2 className='arthur-card-subheader'>{subheader}</h2>}\n      <h1 className='arthur-card-header'>{header}</h1>\n      <div className='arthur-card-headerbreak' />\n    </StyledRoot>\n  );\n}\n\nCardHeading.displayName = 'CardHeading';\n","import type { PropsWithChildren } from 'react';\nimport styled from 'styled-components';\n\nconst StyledRoot = styled.footer`\n  display: flex;\n  justify-content: end;\n  margin-top: ${(props) => props.theme.token.size[7]};\n`;\n\nexport function CardFooter(props: PropsWithChildren) {\n  const { children } = props;\n  return <StyledRoot className='arthur-card-footer'>{children}</StyledRoot>;\n}\n\nCardFooter.displayName = 'CardFooter';\n","import type { PropsWithChildren } from 'react';\nimport styled from 'styled-components';\n\nconst StyledRoot = styled.div`\n  color: ${(props) => props.theme.token.color.black};\n  box-sizing: border-box;\n  margin-top: ${(props) => props.theme.token.size[5]};\n`;\n\nexport function CardContent(props: PropsWithChildren) {\n  const { children } = props;\n  return <StyledRoot>{children}</StyledRoot>;\n}\n\nCardContent.displayName = 'CardContent';\n","import React, { forwardRef } from 'react';\nimport styled from 'styled-components';\nimport classNames from 'classnames';\nimport Button from '../Button';\nimport type { IconValue } from '../Icon';\nimport type { ImageProps } from '../Image';\nimport Image from '../Image';\nimport { CardHeading } from './CardHeading';\nimport { CardFooter } from './CardFooter';\nimport { CardContent } from './CardContent';\nimport { CardVariantEnum, type CardImagePosition, type CardVariant, CardImagePositionEnum } from './types';\n\nconst StyledRoot = styled.div<{ $imagePosition: CardImagePosition }>`\n  box-sizing: border-box;\n  padding: ${(props) => props.theme.token.size[8]} ${(props) => props.theme.token.size.spacing['large-1x']};\n  padding-bottom: ${(props) => props.theme.token.size[5]};\n  display: flex;\n  box-shadow: ${(props) => props.theme.token.shadow.box.small};\n  flex-direction: ${(props) => (props.$imagePosition === 'left' ? 'row' : 'column')};\n\n  &.arthur-card--headerless {\n    padding-top: 0px !important;\n  }\n\n  & .arthur-card-body {\n    color: ${(props) => props.theme.token.color.black};\n  }\n\n  & .arthur-card-image {\n    box-sizing: border-box;\n    margin-right: ${(props) => props.theme.token.size.spacing['large-2x']};\n    flex-shrink: 0;\n  }\n`;\n\nexport interface CardProps {\n  className?: string;\n  /**\n   * @default false\n   */\n  disabled?: boolean;\n  /**\n   * Describes the optional body of this component.\n   *\n   * @default undefined\n   */\n  body?: string;\n\n  /**\n   * Describes the optional header of this component.\n   *\n   * @default undefined\n   */\n  header: string;\n\n  /**\n   * Describes the optional icon alias of this component.\n   *\n   * @default undefined\n   */\n  icon?: IconValue;\n\n  /**\n   * Controls how the image is rendered.\n   *\n   * @default top\n   */\n  imagePosition?: CardImagePosition;\n\n  /**\n   * Allows for full image component customization.\n   *\n   * @default {}\n   */\n  imageProps?: ImageProps;\n\n  /**\n   * Describes the optional image source of this component.\n   *\n   * @default undefined\n   */\n  imageSrc?: string;\n\n  /**\n   * Button click hander\n   *\n   * @default undefined\n   */\n  onAction?: (event: React.MouseEvent<HTMLButtonElement>) => void;\n\n  /**\n   * Describes the optional sub-header of this component.\n   *\n   * @default undefined\n   */\n  subheader?: string;\n  buttonText?: string;\n  variant?: CardVariant;\n  primaryMetadata?: string;\n  secondaryMetadata?: string;\n}\n\nconst Card = forwardRef<HTMLDivElement, CardProps>((props, forwardedRef) => {\n  const {\n    body,\n    className,\n    header,\n    icon,\n    imagePosition = CardImagePositionEnum.top,\n    imageSrc,\n    onAction,\n    subheader,\n    variant = CardVariantEnum.default,\n    primaryMetadata,\n    secondaryMetadata,\n    buttonText,\n    ...rest\n  } = props;\n\n  const classes = classNames(className, 'arthur-card', `arthur-card--variant-${variant}`);\n\n  const isImageFirst = variant !== 'blog';\n  const hasImage = Boolean(imageSrc);\n\n  return (\n    <StyledRoot $imagePosition={imagePosition} className={classes} ref={forwardedRef} {...rest}>\n      {Boolean(isImageFirst && hasImage) && (\n        <Image className='arthur-card-image' maxWidth={imagePosition === 'left' ? '40%' : '100%'} src={imageSrc} />\n      )}\n      <div>\n        <CardHeading\n          header={header}\n          icon={icon}\n          primaryMetadata={primaryMetadata}\n          secondaryMetadata={secondaryMetadata}\n          subheader={subheader}\n          variant={variant}\n        />\n        {Boolean(!isImageFirst && hasImage) && (\n          <Image className='arthur-card-image' maxWidth={imagePosition === 'left' ? '40%' : '100%'} src={imageSrc} />\n        )}\n        {Boolean(body) && <CardContent>{body}</CardContent>}\n        {Boolean(buttonText) && (\n          <CardFooter>\n            <Button onClick={onAction}>{buttonText}</Button>\n          </CardFooter>\n        )}\n      </div>\n    </StyledRoot>\n  );\n});\n\nexport default Card;\nCard.displayName = 'Card';\n","import type { PropsWithChildren } from 'react';\nimport React, { forwardRef, useCallback } from 'react';\nimport styled, { css } from 'styled-components';\nimport classNames from 'classnames';\nimport {\n  ButtonSizesEnum,\n  type ButtonSizes,\n  type ButtonTypes,\n  type ButtonVariants,\n  ButtonTypesEnum,\n  ButtonVariantsEnum,\n} from './types';\n\nexport interface ButtonProps {\n  className?: string;\n  /**\n   * @default false\n   */\n  disabled?: boolean;\n  /**\n   * @default medium\n   */\n  size?: ButtonSizes;\n  /**\n   * @default default\n   */\n  variant?: ButtonVariants;\n  onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;\n  formId?: string;\n  name?: string;\n  /**\n   * @default button\n   */\n  type?: ButtonTypes;\n}\n\nconst buttonSizeStyles = {\n  small: css`\n    font-size: ${(props) => props.theme.token.size.font.small};\n    height: 30px;\n    padding: 0px ${(props) => props.theme.token.size.spacing.small};\n  `,\n  medium: css`\n    font-size: ${(props) => props.theme.token.size.font.medium};\n    height: 40px;\n    padding: 0px ${(props) => props.theme.token.size.spacing.medium};\n  `,\n  large: css`\n    font-size: ${(props) => props.theme.token.size.font.large};\n    height: 50px;\n    padding: 0px ${(props) => props.theme.token.size.spacing.medium};\n  `,\n};\n\nconst buttonVariantStyles = {\n  default: css`\n    background-color: ${(props) => props.theme.token.color.palette.gold.base};\n    color: ${(props) => props.theme.token.color.black};\n\n    &:not(.arthur-button--disabled):hover {\n      background-color: ${(props) => props.theme.token.color.palette.gold.lighter};\n    }\n\n    &:not(.arthur-button--disabled):active {\n      background-color: ${(props) => props.theme.token.color.palette.gold.darker};\n      box-shadow: inset 0 0 0 1px ${(props) => props.theme.token.color.palette.gold.darker},\n        inset 0 0 0 2px ${(props) => props.theme.token.color.white};\n    }\n  `,\n  secondary: css`\n    background-color: ${(props) => props.theme.token.color.palette.gray[80]};\n    color: ${(props) => props.theme.token.color.white};\n\n    &:not(.arthur-button--disabled):hover {\n      background-color: ${(props) => props.theme.token.color.palette.gray[70]};\n    }\n\n    &:not(.arthur-button--disabled):active {\n      background-color: ${(props) => props.theme.token.color.palette.gray[60]};\n      box-shadow: inset 0 0 0 1px ${(props) => props.theme.token.color.palette.gray[60]},\n        inset 0 0 0 2px ${(props) => props.theme.token.color.white};\n    }\n  `,\n  tertiary: css`\n    background-color: transparent;\n    box-shadow: inset 0 0 0 2px ${(props) => props.theme.token.color.palette.gold.base};\n    color: ${(props) => props.theme.token.color.black};\n\n    &:not(.arthur-button--disabled):hover {\n      background-color: ${(props) => props.theme.token.color.palette.gold.lighter};\n      box-shadow: none;\n    }\n\n    &:not(.arthur-button--disabled):active {\n      background-color: ${(props) => props.theme.token.color.palette.gold.darker};\n      box-shadow: inset 0 0 0 1px ${(props) => props.theme.token.color.palette.gold.darker},\n        inset 0 0 0 2px ${(props) => props.theme.token.color.white};\n    }\n\n    &.arthur-button--disabled {\n      background-color: transparent;\n      box-shadow: inset 0 0 0 2px ${(props) => props.theme.token.color.palette.gray[20]};\n    }\n  `,\n  danger: css`\n    background-color: ${(props) => props.theme.token.color.palette.red.base};\n    color: ${(props) => props.theme.token.color.white};\n\n    &:not(.arthur-button--disabled):hover {\n      background-color: ${(props) => props.theme.token.color.palette.red.darker};\n    }\n\n    &:not(.arthur-button--disabled):active {\n      background-color: ${(props) => props.theme.token.color.palette.red.darkest};\n      box-shadow: inset 0 0 0 1px ${(props) => props.theme.token.color.palette.red.darkest},\n        inset 0 0 0 2px ${(props) => props.theme.token.color.white};\n    }\n  `,\n};\n\nconst StyledRoot = styled.button<{\n  variant: ButtonVariants;\n  size: ButtonSizes;\n  type: ButtonTypes;\n  ref: React.ForwardedRef<unknown>;\n}>`\n  border: none;\n  border-radius: ${(props) => props.theme.token.radius.border.pill};\n  font-weight: ${(props) => props.theme.token.weight.font.regular};\n  min-width: 140px;\n  outline: none;\n\n  &.arthur-button--disabled {\n    background-color: ${(props) => props.theme.token.color.palette.gray[20]};\n    color: ${(props) => props.theme.token.color.palette.gray[40]};\n  }\n\n  ${(props) => buttonSizeStyles[props.size]}\n  ${(props) => buttonVariantStyles[props.variant]} {\n    /* HACK: HANDLES TOKENS FOR CHILD ICONS */\n  }\n  & .arthur-icon {\n    margin-left: ${(props) => props.theme.token.size.spacing[props.size === 'large' ? 'small' : 'small-1x']};\n    margin-right: ${(props) => props.theme.token.size.spacing[props.size === 'large' ? 'small' : 'small-1x']};\n\n    &:first-child {\n      margin-left: 0px;\n    }\n\n    &:last-child {\n      margin-right: 0px;\n    }\n  }\n`;\n\nconst Button = forwardRef((props: PropsWithChildren<ButtonProps>, forwardedRef) => {\n  const {\n    children,\n    className,\n    disabled = false,\n    size = ButtonSizesEnum.medium,\n    type = ButtonTypesEnum.button,\n    variant = ButtonVariantsEnum.default,\n    onClick,\n    ...rest\n  } = props;\n\n  const classes = classNames(\n    className,\n    'arthur-button',\n    `arthur-button--size-${size}`,\n    `arthur-button--variant-${variant}`,\n    {\n      'arthur-button--disabled': disabled,\n    },\n  );\n\n  const handleClick = useCallback(\n    (event: React.MouseEvent<HTMLButtonElement>) => {\n      onClick?.(event);\n    },\n    [onClick],\n  );\n\n  return (\n    <StyledRoot\n      className={classes}\n      disabled={disabled}\n      onClick={handleClick}\n      ref={forwardedRef}\n      role='button'\n      size={size}\n      type={type}\n      variant={variant}\n      {...rest}\n    >\n      {children}\n    </StyledRoot>\n  );\n});\n\nexport default Button;\n\nButton.displayName = 'Button';\n","import React, { forwardRef, useCallback } from 'react';\nimport styled, { css } from 'styled-components';\nimport classNames from 'classnames';\nimport { type IconValue, type IconSizes, IconSizesEnum } from './types';\nimport { ICON_VALUES } from './constants';\n\nexport interface IconProps {\n    className?: string;\n    /**\n     * @default false\n     */\n    disabled?: boolean;\n    /**\n     * @default medium\n     */\n    size?: IconSizes;\n    onClick?: (event: React.MouseEvent<HTMLSpanElement>) => unknown;\n    value: IconValue;\n}\n\nconst iconSizeStyles = {\n    'small-1x': css`\n        font-size: ${(props) => props.theme.token.size.font['small-1x']};\n    `,\n    small: css`\n        font-size: ${(props) => props.theme.token.size.font.small};\n    `,\n    medium: css`\n        font-size: ${(props) => props.theme.token.size.font.medium};\n    `,\n    large: css`\n        font-size: ${(props) => props.theme.token.size.font.large};\n    `,\n};\n\nconst StyledRoot = styled.span<{ disabled?: boolean }>`\n    background-color: transparent;\n    border: 0px none;\n    outline: 0px none;\n    padding: 0px;\n\n    &:not(.arthur-icon--disabled) {\n        &.arthur-icon--clickable {\n            &:hover,\n            &:focus,\n            &:active {\n                color: ${(props) => props.theme.token.color.palette.gold.base};\n                cursor: pointer;\n                outline: 0px none;\n            }\n        }\n    }\n\n    &.arthur-icon--disabled {\n        color: ${(props) => props.theme.token.color.action.text.primary.disabled};\n        cursor: default;\n    }\n`;\n\nconst StyledIcon = styled.i<{ size: IconSizes }>`\n    ${(props) => iconSizeStyles[props.size]}\n`;\n\nconst Icon = forwardRef<HTMLSpanElement | HTMLButtonElement, IconProps>((props, forwardedRef) => {\n    const { className, disabled, size = 'medium', value, onClick, ...rest } = props;\n\n    const iconClass = ICON_VALUES[value];\n\n    if (!IconSizesEnum[size]) {\n        throw new Error(`icon: invalid size \"${size}\"`);\n    }\n\n    const isClickable = disabled === true || typeof onClick === 'function';\n\n    const handleClick = useCallback(\n        (event: React.MouseEvent<HTMLSpanElement>) => {\n            if (disabled) return;\n\n            onClick?.(event);\n        },\n        [disabled, onClick],\n    );\n\n    const classes = {\n        root: classNames(className, 'arthur-icon', `arthur-icon--size-${size}`, {\n            'arthur-icon--clickable': isClickable,\n            'arthur-icon--disabled': disabled === true,\n        }),\n        regular: classNames('arthur-icon-regular', 'fa-regular', {\n            'fa-foobar': Boolean(iconClass) && Boolean(value),\n            [iconClass]: Boolean(iconClass),\n            [value as string]: Boolean(iconClass) && Boolean(value),\n        }),\n    };\n\n    // The wrapping span is needed because an error is thrown if one attempts\n    // to remove this from the dom once it is rendered. This is because the \"rendered\"\n    // node is the <i /> element, but a sibling <svg /> element is created as well.\n    // Without the wrapper and in the case that the element is added and removed again,\n    // React throws.\n    return (\n        <StyledRoot\n            as={isClickable ? 'button' : 'span'}\n            className={classes.root}\n            disabled={disabled}\n            onClick={handleClick}\n            ref={forwardedRef}\n        >\n            <StyledIcon className={classes.regular} size={size} {...rest} />\n        </StyledRoot>\n    );\n});\n\nexport default Icon;\n\nIcon.displayName = 'Icon';\n","// istanbul ignore file: it is difficult to load images to then test the auto-layout portion of the code here; however, the story for this component covers all scenarios\nimport type { CSSProperties, ReactEventHandler, SyntheticEvent } from 'react';\nimport React, { forwardRef, useCallback, useEffect, useMemo, useState } from 'react';\nimport styled from 'styled-components';\nimport classNames from 'classnames';\nimport Icon from '../Icon';\nimport { useEnsureRef } from '../hook';\n\nconst StyledRoot = styled.span<ImageProps & TransientProps>`\n  align-items: center;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n  overflow: hidden;\n\n  &.arthur-image--failure {\n    & .arthur-image-icon {\n      &::after {\n        ${(props) => (props.$errorText || props.$alt) && `margin-left: ${props.theme.token.size.spacing['small-2x']};`}\n        content: \"${(props) => props.$errorText || props.$alt || ''}\";\n      }\n    }\n  }\n`;\n\nexport interface ImageProps {\n  className?: string;\n  /**\n   * Describes the [standard \"alt\" attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#alt) on img elements.\n   *\n   * @default undefined\n   */\n  alt?: string;\n\n  /**\n   * Controls whether or not the inner image should center and proportion itself to its parent element.\n   *\n   * @default true\n   */\n  autoLayout?: boolean;\n\n  /**\n   * Describes the text to be displayed after the ImageProps#onError event fires.\n   *\n   * @default undefined\n   */\n  errorText?: string;\n\n  /**\n   * Describes the height style of the root element. When provided as a number, it is treated as pixels.\n   *\n   * @default undefined\n   */\n  height?: string | number;\n\n  /**\n   * Describes the max-height style of the root element. When provided as a number, it is treated as pixels.\n   *\n   * @default undefined\n   */\n  maxHeight?: string | number;\n\n  /**\n   * Describes the max-width style of the root element. When provided as a number, it is treated as pixels.\n   *\n   * @default undefined\n   */\n  maxWidth?: string | number;\n\n  /**\n   * Describes the min-height style of the root element. When provided as a number, it is treated as pixels.\n   *\n   * @default undefined\n   */\n  minHeight?: string | number;\n\n  /**\n   * Describes the min-width style of the root element. When provided as a number, it is treated as pixels.\n   *\n   * @default undefined\n   */\n  minWidth?: string | number;\n\n  /**\n   * Describes the [standard \"src\" attribute](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#src) on img elements.\n   *\n   * @default \"\"\n   */\n  src?: string;\n\n  /**\n   * Describes the width style of the root element. When provided as a number, it is treated as pixels.\n   *\n   * @default undefined\n   */\n  width?: string | number;\n\n  /**\n   * Handles the [standard \"onerror\" event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/error_event) on HTML elements.\n   *\n   * @default undefined\n   */\n  onError?: (event: SyntheticEvent<HTMLImageElement>) => void;\n\n  /**\n   * Handles the [standard \"onload\" event](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/load_event) on HTML elements.\n   *\n   * @default undefined\n   */\n  onLoad?: (event: SyntheticEvent<HTMLImageElement>) => void;\n  style?: CSSProperties;\n}\n\ninterface TransientProps {\n  $alt?: string;\n  $errorText?: string;\n}\n\nconst Image = forwardRef<HTMLSpanElement, ImageProps>((props, forwardedRef) => {\n  const {\n    alt,\n    autoLayout,\n    className,\n    errorText,\n    height,\n    maxHeight,\n    maxWidth,\n    minHeight,\n    minWidth,\n    src,\n    style,\n    width,\n    onError,\n    onLoad,\n    ...rest\n  } = props;\n\n  const rootRef = useEnsureRef(forwardedRef);\n  const [loaded, setLoaded] = useState<boolean | null>(null);\n\n  // useEffect(() => {\n  //   setLoaded(null);\n  // }, [src]);\n\n  useEffect(() => {\n    let timeoutId: NodeJS.Timeout;\n    function onResize() {\n      // resets timeout if applicable\n      clearTimeout(timeoutId);\n\n      // throttle resize calculations if resize events are happening in quick succession\n      timeoutId = setTimeout(() => {\n        rootRef.current && doLayout(rootRef.current);\n      }, 150);\n    }\n\n    if (autoLayout === true && rootRef.current) {\n      window.addEventListener('resize', onResize);\n    }\n\n    return () => {\n      clearTimeout(timeoutId);\n      window.removeEventListener('resize', onResize);\n    };\n  }, [autoLayout, rootRef]);\n\n  const classes = classNames(className, 'arthur-image', {\n    'arthur-image--success': loaded,\n    'arthur-image--failure': !loaded,\n  });\n\n  const styles = useMemo(() => {\n    return {\n      height: formatSize(height),\n      maxHeight: formatSize(maxHeight),\n      maxWidth: formatSize(maxWidth),\n      minHeight: formatSize(minHeight),\n      minWidth: formatSize(minWidth),\n      width: formatSize(width),\n      ...style,\n    };\n  }, [height, maxHeight, maxWidth, minHeight, minWidth, style, width]);\n\n  const handleOnError = useCallback<ReactEventHandler<HTMLImageElement>>(\n    (event: SyntheticEvent<HTMLImageElement>) => {\n      setLoaded(false);\n      onError?.(event);\n    },\n    [onError],\n  );\n\n  const handleOnLoad = useCallback<ReactEventHandler<HTMLImageElement>>(\n    (event: SyntheticEvent<HTMLImageElement>) => {\n      if (autoLayout === true && rootRef.current) {\n        doLayout(rootRef.current);\n      }\n\n      setLoaded(true);\n      onLoad?.(event);\n    },\n    [autoLayout, onLoad, rootRef],\n  );\n  console.log('%c loaded', 'color: magenta;', loaded);\n\n  return (\n    <StyledRoot $alt={alt} $errorText={errorText} className={classes} ref={rootRef} style={styles}>\n      {!loaded && <Icon className='arthur-image-icon' size='large' value='fa-image-slash' />}\n      <img\n        alt={alt}\n        className='arthur-image-img'\n        onError={handleOnError}\n        onLoad={handleOnLoad}\n        src={src || ''} // REMARK: THIS WILL FORCE THE ERROR EVENT TO FIRE IN THE EVENT THAT NOTHING IS PROVIDED TO ImageProps#src\n        {...rest}\n      />\n    </StyledRoot>\n  );\n});\n\nexport default Image;\nImage.displayName = 'Image';\n\nfunction formatSize(value?: string | number): string | undefined {\n  if (typeof value === 'number') {\n    return `${value}px`;\n  }\n\n  if (Boolean(value) && typeof value === 'string') {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction doLayout(root: HTMLSpanElement) {\n  const { offsetHeight: rootH, offsetWidth: rootW } = root;\n\n  const img = root.querySelector<HTMLImageElement>('.arthur-image-img');\n  if (!img) {\n    return;\n  }\n\n  const { naturalHeight: imgH, naturalWidth: imgW } = img;\n\n  if (imgH <= 0 || imgW <= 0) {\n    return;\n  }\n\n  let newW: number | undefined;\n  let newH: number | undefined;\n\n  // if landscape img\n  if (imgW > imgH) {\n    if (rootW > rootH) {\n      if (imgW >= rootW) {\n        newW = rootW;\n      } else {\n        newH = rootH;\n      }\n    } else {\n      newH = rootH;\n    }\n    // if portrait img\n  } else if (imgW < imgH) {\n    if (rootW < rootH) {\n      if (imgH >= rootH) {\n        newH = rootH;\n      } else {\n        newW = rootW;\n      }\n    } else {\n      newW = rootW;\n    }\n    // if square img\n  } else if (rootW < rootH) {\n    newH = rootH;\n  } else {\n    newW = rootW;\n  }\n\n  if (newW) {\n    img.style.width = `${newW}px`;\n  }\n\n  if (newH) {\n    img.style.height = `${newH}px`;\n  }\n\n  // the above centering/scaling works most of the time,\n  // but it does fail to completely fill the root element;\n  // the below conditionally applies a minor adjustment if necessary\n  if (newH && root.offsetWidth > img.offsetWidth) {\n    img.style.width = `${root.offsetWidth}px`;\n  } else if (newW && root.offsetHeight > img.offsetHeight) {\n    img.style.height = `${root.offsetHeight}px`;\n  }\n}\n"],"names":[],"sourceRoot":""}